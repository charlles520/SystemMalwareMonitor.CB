using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SFMCB.Utilitários
{
    public static class AdjustPriv
    {
        private const int ANYSIZE_ARRAY = 1;

        private const int TOKEN_QUERY = 8;

        private const int TOKEN_ADJUST_PRIVILEGES = 32;

        private const string SE_DEBUG_NAME = "SeDebugPrivilege";

        private const int SE_PRIVILEGE_ENABLED = 2;

        //Creditos ->
        //http://www.vbforums.com/showthread.php?674058-RESOLVED-Adjusting-Token-Privlidges-Error
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool CloseHandle(IntPtr hObject);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, ref LUID lpLuid);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool OpenProcessToken(IntPtr ProcessHandle, int DesiredAccess, ref IntPtr TokenHandle);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges,
            ref TOKEN_PRIVILEGES NewState, int BufferLength, ref TOKEN_PRIVILEGES PreviousState,
            ref IntPtr ReturnLength);

        public static void AdjustToken()
        {
            var luid_Debug = new LUID();
            var flag = !LookupPrivilegeValue(null, "SeDebugPrivilege", ref luid_Debug);
            if (flag)
            {
                var lastWin32Error = Marshal.GetLastWin32Error();
                throw new Win32Exception(lastWin32Error,
                    "LookupPrivilegeValue failed with error " + lastWin32Error + ".");
            }

            var hProc = Process.GetCurrentProcess().Handle;
            var hToken = new IntPtr();
            var flag2 = !OpenProcessToken(hProc, 40, ref hToken);
            if (flag2)
            {
                var lastWin32Error = Marshal.GetLastWin32Error();
                throw new Win32Exception(lastWin32Error, "OpenProcessToken failed with error " + lastWin32Error + ".");
            }

            try
            {
                var luaAttr = default(LUID_AND_ATTRIBUTES);
                luaAttr.Luid = luid_Debug;
                luaAttr.Attributes = 2u;
                var newState = default(TOKEN_PRIVILEGES);
                newState.PrivilegeCount = 1u;
                newState.Privileges = new[]
                {
                    luaAttr
                };
                var prevState = default(TOKEN_PRIVILEGES);
                prevState.Privileges = new LUID_AND_ATTRIBUTES[checked((int) newState.PrivilegeCount + 1)];
                var tokenHandle = hToken;
                var disableAllPrivileges = false;
                var bufferLength = Marshal.SizeOf(prevState);
                var token_PRIVILEGES = default(TOKEN_PRIVILEGES);
                var intPtr = IntPtr.Zero;
                var flag3 = !AdjustTokenPrivileges(tokenHandle, disableAllPrivileges, ref newState, bufferLength,
                    ref token_PRIVILEGES, ref intPtr);
                if (flag3)
                {
                    var lastWin32Error = Marshal.GetLastWin32Error();
                    throw new Win32Exception(lastWin32Error,
                        "AdjustTokenPrivileges failed with error " + lastWin32Error + ".");
                }
            }
            finally
            {
                CloseHandle(hToken);
            }
        }

        public struct LUID
        {
            public uint LowPart;

            public uint HighPart;
        }

        public struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;

            public uint Attributes;
        }

        public struct TOKEN_PRIVILEGES
        {
            public uint PrivilegeCount;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
            public LUID_AND_ATTRIBUTES[] Privileges;
        }
    }
}